dds1 <- DESeq2::DESeqDataSetFromMatrix(
countData = counts[,as.numeric(c(cells.1, cells.2))],
colData = group.info,
design = ~ group
)
dds1 <- DESeq2::estimateSizeFactors(object = dds1)
dds1 <- DESeq2::estimateDispersions(object = dds1, fitType = "local")
dds1 <- DESeq2::nbinomWaldTest(object = dds1)
res <- DESeq2::results(
object = dds1,
contrast = c("group", "Group1", "Group2")
)
res <- res[order(res$padj),]
resLFC <- res
summary(resLFC, alpha=0.05)
DT::datatable(as.data.frame(resLFC), extensions = 'FixedColumns',
options = list(
pageLength = 20,
scrollX = TRUE,
scrollCollapse = TRUE,
dom = 'Bfrtip',
buttons = c('copy', 'csv', 'excel', 'pdf', 'print')
))
#write.csv(resLFC,"comparison1.csv")
eg = bitr(rownames(counts), fromType="ENTREZID", toType="SYMBOL", OrgDb="org.Hs.eg.db")
eg
rownames(counts)[1:10]
rownames(counts) <- eg$SYMBOL
nrow(eg$SYMBOL)
nrow(eg)
length(rownames(counts))
eg
expFile <- merge(counts,eg,by.x=0,by.y=ENTREZID)
expFile <- merge(counts,eg,by.x=0,by.y="ENTREZID")
expFile
dim(expFile)
expFile <- na.omit(expFile)
dim(expFile)
expFile <- expFile[,-1]
expFile <- aggregate(. ~ ENTREZID, expFile, sum)
View(expFile)
expFile <- aggregate(. ~ SYMBOL, expFile, sum)
expFile[,1]
View(expFile)
expFile <- expFile[!duplicated(expFile[,1]),]
rownames(expFile) <- expFile[,1]
expFile <- expFile[,-1]
expFile
counts <- read.csv("counts.csv",stringsAsFactors = F,check.names = F)
meta <- read.csv("meta.csv",stringsAsFactors = F)
# Remove duplicated row names
if(length(which(duplicated.default(counts[,1]))) > 0 ){
counts <- counts[-which(duplicated.default(counts[,1])==T),]
}
rownames(counts) <- counts[,1]
counts <- counts[,-1]
eg = bitr(rownames(counts), fromType="ENTREZID", toType="SYMBOL", OrgDb="org.Hs.eg.db")
expFile <- merge(counts,eg,by.x=0,by.y="ENTREZID")
dim(expFile)
expFile <- na.omit(expFile)
expFile <- expFile[,-1]
expFile <- aggregate(. ~ SYMBOL, expFile, sum)
expFile <- expFile[!duplicated(expFile[,1]),]
rownames(expFile) <- expFile[,1]
expFile <- expFile[,-1]
counts <- expFile
# You can filter the genes with low counts, it is called most minimal filtering rule: removing rows of the dataset that have no counts, or only a count of 10 across all samples. The value can be adjusted based on your dataset condition.
keep <- rowSums(counts) >= 10
# For some datasets, it may make sense to perform additional filtering. For example, one can specify that at least 5 samples have a count of 10 or higher. One recommendation for the number of samples would be set to the smallest group size.
keep <- rowSums(counts >= 10) >= 5
counts <- counts[keep, ]
# For example use and speed up the process, we only select top 4000 genes for downstream analysis, remember to delete this line
#counts <- counts[sample(1:nrow(counts),4000),]
# Overview of the dataset
#counts[1:10, 1:10]
meta
obj <- CreateSeuratObject(counts, project = 'rnaseq')
obj <- NormalizeData(object = obj, normalization.method = 'LogNormalize', scale.factor = 1000000)
# choose whahtever column as design
dds <- DESeq2::DESeqDataSetFromMatrix(
countData = counts,
colData = meta,
design = ~ condition
)
vsd <- vst(dds, blind = FALSE)
obj <- AddMetaData(obj, meta$condition, col.name = "condition")
Idents(obj) <- obj$condition
VlnPlot(obj,"TET2")
s1 <- subset(meta, meta$condition == "KO")
s2 <- subset(meta, meta$condition == "control")
cells.1 = rownames(s1)
cells.2 = rownames(s2)
group.info <- data.frame(row.names = c(cells.1, cells.2))
group.info[cells.1, "group"] <- "Group1"
group.info[cells.2, "group"] <- "Group2"
group.info[, "group"] <- factor(x = group.info[, "group"])
group.info$wellKey <- rownames(x = group.info)
dds1 <- DESeq2::DESeqDataSetFromMatrix(
countData = counts[,as.numeric(c(cells.1, cells.2))],
colData = group.info,
design = ~ group
)
dds1 <- DESeq2::estimateSizeFactors(object = dds1)
dds1 <- DESeq2::estimateDispersions(object = dds1, fitType = "local")
dds1 <- DESeq2::nbinomWaldTest(object = dds1)
res <- DESeq2::results(
object = dds1,
contrast = c("group", "Group1", "Group2")
)
res <- res[order(res$padj),]
resLFC <- res
summary(resLFC, alpha=0.05)
DT::datatable(as.data.frame(resLFC), extensions = 'FixedColumns',
options = list(
pageLength = 20,
scrollX = TRUE,
scrollCollapse = TRUE,
dom = 'Bfrtip',
buttons = c('copy', 'csv', 'excel', 'pdf', 'print')
))
write.csv(resLFC,"project2_KO_vs_control.csv")
ggmaplot(resLFC,
fdr = 0.05, fc = 1.5, size = 0.5,
palette = c("#B31B21", "#1465AC", "darkgray"),
genenames = as.vector(rownames(resLFC)),
legend = "top", top = 10,
font.label = c("bold", 11),
font.legend = "bold",
font.main = "bold",
ggtheme = ggplot2::theme_minimal())
as.vector(rownames(resLFC))
top_up <- rownames(resLFC[which(resLFC$log2FoldChange > 0),])[1:5]
top_down <- rownames(resLFC[which(resLFC$log2FoldChange < 0),])[1:5]
EnhancedVolcano(resLFC,
lab = rownames(resLFC),
x = 'log2FoldChange',
y = 'padj',
selectLab = c(top_up,top_down),
xlim = c(-8, 8),
pCutoff = 0.05,
FCcutoff = 1.5,
)
top_up
rownames(resLFC) == "TET2"
which(rownames(resLFC) == "TET2")
resLFC[8530,]
top_up <- rownames(resLFC[which(resLFC$log2FoldChange > 0),])[1:5]
top_down <- rownames(resLFC[which(resLFC$log2FoldChange < 0),])[1:5]
#which(rownames(resLFC) == "TET2")
#resLFC[8530,]
top_up <- c(top_up,"TET2")
EnhancedVolcano(resLFC,
lab = rownames(resLFC),
x = 'log2FoldChange',
y = 'padj',
selectLab = c(top_up,top_down),
xlim = c(-8, 8),
pCutoff = 0.05,
FCcutoff = 1.5,
)
resLFC[8530,]
obj <- CreateSeuratObject(counts, project = 'rnaseq')
VlnPlot(obj,"TET2")
Idents(obj) <- obj$condition
obj <- AddMetaData(obj, meta$condition, col.name = "condition")
Idents(obj) <- obj$condition
VlnPlot(obj,"TET2")
vsd
vsd@assays@data
cts <- assay(vsd)
obj2 <- CreateSeuratObject(cts, project = 'rnaseq')
obj2 <- AddMetaData(obj2, meta$condition, col.name = "condition")
Idents(obj2) <- obj2$condition
VlnPlot(obj2,"TET2")
# This select genes of adj.p.value < 0.05, sometimes people use different threshold, like adding log2foldchange threshold.
#enriched_combined <- enrichr(rownames(resLFC[which(resLFC$padj < 0.05),]),dbs)
# This add log2foldchange threshold.
enriched_combined <- enrichr(rownames(resLFC[which(resLFC$padj < 0.05 & abs(resLFC$log2FoldChange) > 1.5),]),dbs)
# output top 20 enriched terms
DT::datatable(head(enriched_combined$GO_Biological_Process_2018,n=20)[,c(-3,-5,-6,-7)], extensions = c('FixedColumns','Buttons'),
options = list(
pageLength = 5,
scrollX = TRUE,
scrollCollapse = TRUE,
dom = 'Bfrtip',
buttons = c('copy', 'csv', 'excel')
))
# output top 20 enriched terms
DT::datatable(head(enriched_combined$GO_Biological_Process_2018,n=20)[,c(-3,-5,-6,-7)], extensions = c('FixedColumns','Buttons'),
options = list(
pageLength = 5,
scrollX = TRUE,
scrollCollapse = TRUE,
dom = 'Bfrtip',
buttons = c('copy', 'csv', 'excel')
))
enriched_combined
enriched_combined$GO_Biological_Process_2018
enriched_combined
dbs
dbs <- c("GO_Molecular_Function_2018", "GO_Cellular_Component_2018", "GO_Biological_Process_2018","KEGG_2019_Human")
# This select genes of adj.p.value < 0.05, sometimes people use different threshold, like adding log2foldchange threshold.
#enriched_combined <- enrichr(rownames(resLFC[which(resLFC$padj < 0.05),]),dbs)
# This add log2foldchange threshold.
enriched_combined <- enrichr(rownames(resLFC[which(resLFC$padj < 0.05 & abs(resLFC$log2FoldChange) > 1.5),]),dbs)
# output top 20 enriched terms
DT::datatable(head(enriched_combined$GO_Biological_Process_2018,n=20)[,c(-3,-5,-6,-7)], extensions = c('FixedColumns','Buttons'),
options = list(
pageLength = 5,
scrollX = TRUE,
scrollCollapse = TRUE,
dom = 'Bfrtip',
buttons = c('copy', 'csv', 'excel')
))
DT::datatable(head(enriched_combined$GO_Cellular_Component_2018,n=20)[,c(-3,-5,-6,-7)], extensions = c('FixedColumns','Buttons'),
options = list(
pageLength = 5,
scrollX = TRUE,
scrollCollapse = TRUE,
dom = 'Bfrtip',
buttons = c('copy', 'csv', 'excel')
))
DT::datatable(head(enriched_combined$GO_Molecular_Function_2018,n=20)[,c(-3,-5,-6,-7)], extensions = c('FixedColumns','Buttons'),
options = list(
pageLength = 5,
scrollX = TRUE,
scrollCollapse = TRUE,
dom = 'Bfrtip',
buttons = c('copy', 'csv', 'excel')
))
DT::datatable(head(enriched_combined$KEGG_2019_Mouse,n=20)[,c(-3,-5,-6,-7)], extensions = c('FixedColumns','Buttons'),
options = list(
pageLength = 5,
scrollX = TRUE,
scrollCollapse = TRUE,
dom = 'Bfrtip',
buttons = c('copy', 'csv', 'excel')
))
DT::datatable(head(enriched_combined$KEGG_2019_Human,n=20)[,c(-3,-5,-6,-7)], extensions = c('FixedColumns','Buttons'),
options = list(
pageLength = 5,
scrollX = TRUE,
scrollCollapse = TRUE,
dom = 'Bfrtip',
buttons = c('copy', 'csv', 'excel')
))
meta$condition
s1 <- subset(meta, meta$condition == "KO_IFNy")
s2 <- subset(meta, meta$condition == "control_IFNy")
cells.1 = rownames(s1)
cells.2 = rownames(s2)
group.info <- data.frame(row.names = c(cells.1, cells.2))
group.info[cells.1, "group"] <- "Group1"
group.info[cells.2, "group"] <- "Group2"
group.info[, "group"] <- factor(x = group.info[, "group"])
group.info$wellKey <- rownames(x = group.info)
dds1 <- DESeq2::DESeqDataSetFromMatrix(
countData = counts[,as.numeric(c(cells.1, cells.2))],
colData = group.info,
design = ~ group
)
dds1 <- DESeq2::estimateSizeFactors(object = dds1)
dds1 <- DESeq2::estimateDispersions(object = dds1, fitType = "local")
dds1 <- DESeq2::nbinomWaldTest(object = dds1)
res <- DESeq2::results(
object = dds1,
contrast = c("group", "Group1", "Group2")
)
res <- res[order(res$padj),]
resLFC <- res
summary(resLFC, alpha=0.05)
DT::datatable(as.data.frame(resLFC), extensions = 'FixedColumns',
options = list(
pageLength = 20,
scrollX = TRUE,
scrollCollapse = TRUE,
dom = 'Bfrtip',
buttons = c('copy', 'csv', 'excel', 'pdf', 'print')
))
write.csv(resLFC,"project2_KO_IFNy_vs_control_IFNy.csv")
ggmaplot(resLFC,
fdr = 0.05, fc = 1.5, size = 0.5,
palette = c("#B31B21", "#1465AC", "darkgray"),
genenames = as.vector(rownames(resLFC)),
legend = "top", top = 10,
font.label = c("bold", 11),
font.legend = "bold",
font.main = "bold",
ggtheme = ggplot2::theme_minimal())
top_up <- rownames(resLFC[which(resLFC$log2FoldChange > 0),])[1:5]
top_down <- rownames(resLFC[which(resLFC$log2FoldChange < 0),])[1:5]
#which(rownames(resLFC) == "TET2")
#resLFC[8530,]
top_up <- c(top_up,"TET2")
EnhancedVolcano(resLFC,
lab = rownames(resLFC),
x = 'log2FoldChange',
y = 'padj',
selectLab = c(top_up,top_down),
xlim = c(-8, 8),
pCutoff = 0.05,
FCcutoff = 1.5,
)
which(rownames(resLFC) == "TET2")
resLFC[1351,]
EnhancedVolcano(resLFC,
lab = rownames(resLFC),
x = 'log2FoldChange',
y = 'padj',
selectLab = c(top_up,top_down),
xlim = c(-8, 8),
pCutoff = 0.05,
FCcutoff = 1.5,
)
resLFC[1351,]
EnhancedVolcano(resLFC,
lab = rownames(resLFC),
x = 'log2FoldChange',
y = 'padj',
selectLab = c(top_up,top_down),
xlim = c(-8, 8),
pCutoff = 0.05,
FCcutoff = 1.5,
)
# This select genes of adj.p.value < 0.05, sometimes people use different threshold, like adding log2foldchange threshold.
#enriched_combined <- enrichr(rownames(resLFC[which(resLFC$padj < 0.05),]),dbs)
# This add log2foldchange threshold.
enriched_combined <- enrichr(rownames(resLFC[which(resLFC$padj < 0.05 & resLFC$log2FoldChange > 1.5),]),dbs)
# output top 20 enriched terms
DT::datatable(head(enriched_combined$GO_Biological_Process_2018,n=20)[,c(-3,-5,-6,-7)], extensions = c('FixedColumns','Buttons'),
options = list(
pageLength = 5,
scrollX = TRUE,
scrollCollapse = TRUE,
dom = 'Bfrtip',
buttons = c('copy', 'csv', 'excel')
))
# This select genes of adj.p.value < 0.05, sometimes people use different threshold, like adding log2foldchange threshold.
#enriched_combined <- enrichr(rownames(resLFC[which(resLFC$padj < 0.05),]),dbs)
# This add log2foldchange threshold.
enriched_combined <- enrichr(rownames(resLFC[which(resLFC$padj < 0.05 & resLFC$log2FoldChange < -1.5),]),dbs)
# output top 20 enriched terms
DT::datatable(head(enriched_combined$GO_Biological_Process_2018,n=20)[,c(-3,-5,-6,-7)], extensions = c('FixedColumns','Buttons'),
options = list(
pageLength = 5,
scrollX = TRUE,
scrollCollapse = TRUE,
dom = 'Bfrtip',
buttons = c('copy', 'csv', 'excel')
))
esLFC[1351,]
resLFC[1351,]
s1 <- subset(meta, meta$condition == "KO")
s2 <- subset(meta, meta$condition == "control")
cells.1 = rownames(s1)
cells.2 = rownames(s2)
group.info <- data.frame(row.names = c(cells.1, cells.2))
group.info[cells.1, "group"] <- "Group1"
group.info[cells.2, "group"] <- "Group2"
group.info[, "group"] <- factor(x = group.info[, "group"])
group.info$wellKey <- rownames(x = group.info)
dds1 <- DESeq2::DESeqDataSetFromMatrix(
countData = counts[,as.numeric(c(cells.1, cells.2))],
colData = group.info,
design = ~ group
)
dds1 <- DESeq2::estimateSizeFactors(object = dds1)
dds1 <- DESeq2::estimateDispersions(object = dds1, fitType = "local")
dds1 <- DESeq2::nbinomWaldTest(object = dds1)
res <- DESeq2::results(
object = dds1,
contrast = c("group", "Group1", "Group2")
)
res <- res[order(res$padj),]
resLFC <- res
summary(resLFC, alpha=0.05)
DT::datatable(as.data.frame(resLFC), extensions = 'FixedColumns',
options = list(
pageLength = 20,
scrollX = TRUE,
scrollCollapse = TRUE,
dom = 'Bfrtip',
buttons = c('copy', 'csv', 'excel', 'pdf', 'print')
))
write.csv(resLFC,"project2_KO_vs_control.csv")
resLFC[8530,]
bitr
library(tidyverse)
library(RVenn)
library(rlist)
library(knitr)
library(RMySQL)
library(fst)
library(preprocessCore)
library(cowplot)
library(MAST)
install.packages("RVenn", lib="C:/Program Files/Microsoft/R Open/R-4.0.2/library")
install.packages("rlist", lib="C:/Program Files/Microsoft/R Open/R-4.0.2/library")
install.packages("RMySQL", lib="C:/Program Files/Microsoft/R Open/R-4.0.2/library")
install.packages("fst", lib="C:/Program Files/Microsoft/R Open/R-4.0.2/library")
install.packages("preprocessCore", lib="C:/Program Files/Microsoft/R Open/R-4.0.2/library")
install.packages("cowplot", lib="C:/Program Files/Microsoft/R Open/R-4.0.2/library")
library(tidyverse)
library(RVenn)
library(rlist)
library(knitr)
library(RMySQL)
library(fst)
library(preprocessCore)
library(cowplot)
library(MAST)
load(url('https://raw.githubusercontent.com/OSU-BMBL/scread-protocol/master/overlapping_genes/scread_db.rdata'))
source(url('https://raw.githubusercontent.com/OSU-BMBL/scread-protocol/master/overlapping_genes/overlap_functions.R'))
REGION_LIST <- sort(unique(dataset$region))
CT_LIST <- sort(unique(cell_type_meta$cell_type))
CT_SHORT_LIST <- CT_LIST
CT_SHORT_LIST[CT_LIST=="Oligodendrocyte precursor cells"] <- "opc"
CT_SHORT_LIST <- tolower(substr(CT_SHORT_LIST, 1, 3))
TOP <- 100
this_species <- 'Human'
this_region <- REGION_LIST[5]
this_direction <- 'up'
OVERLAP_THRES <- 3
result <- calc_overlap_list()
print(result$list)
print(result$rank)
options(future.globals.maxSize = 8000 * 1024^2)
suppressPackageStartupMessages(library(fst))
suppressPackageStartupMessages(library(Seurat))
suppressPackageStartupMessages(library(RColorBrewer))
suppressPackageStartupMessages(library(Polychrome))
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(harmony))
suppressPackageStartupMessages(library(cowplot))
suppressPackageStartupMessages(library(future))
wd <- 'C:/Users/flyku/Documents/GitHub/iris3-backend/plumber/data'
atlas_filename <- "atlas_example.rds"
query_filename <- "Zeisel_expression.fst"
query_data_id <- "query_example"
setwd(wd)
source("functions.R")
source("functions.R")
####### Load raw files
#atlas.obj <- atlas
atlas.obj <- read_rds(atlas_filename)
atlas_filename
atlas_filename <- "atlas.rds"
####### Load raw files
#atlas.obj <- atlas
atlas.obj <- read_rds(atlas_filename)
atlas_filename <- "mouse_brain_atlas.rds"
####### Load raw files
#atlas.obj <- atlas
atlas.obj <- read_rds(atlas_filename)
query_matrix <- read.fst(query_filename)
rownames(query_matrix) <- NULL
query_matrix <- column_to_rownames(query_matrix, var = "X1")
query.obj <- CreateSeuratObject(query_matrix, project = "all", min.cells = 5)
query.obj <- FindVariableFeatures(query.obj, selection.method = "vst", nfeatures = 2000)
query.obj.gene <- rownames(query.obj)
query.obj <- ScaleData(query.obj, features = query.obj.gene)
query.obj <- RunPCA(query.obj, features = VariableFeatures(object = query.obj))
query.obj <- RunUMAP(query.obj, reduction = "pca", dims = 1:25)
## FindTransferAnchors: We recommend using PCA when reference and query datasets are from scRNA-seq
transfer.anchors <- FindTransferAnchors(reference = atlas.obj, query = query.obj, features = VariableFeatures(object = atlas.obj), reduction = "pcaproject",verbose = TRUE)
atlas.obj
query.obj
atlas.obj
VariableFeatures(object = atlas.obj)
atlas.obj <- FindVariableFeatures(atlas.obj, selection.method = "vst", nfeatures = 2000)
## FindTransferAnchors: We recommend using PCA when reference and query datasets are from scRNA-seq
transfer.anchors <- FindTransferAnchors(reference = atlas.obj, query = query.obj, features = VariableFeatures(object = atlas.obj), reduction = "pcaproject",verbose = TRUE)
if(nrow(transfer.anchors@anchors) > 30) {
celltype.predictions <- TransferData(anchorset = transfer.anchors, refdata = atlas.obj$cell_type, weight.reduction = query.obj[["pca"]],l2.norm = FALSE,dims = 1:25, k.weight = 30)
} else{
celltype.predictions <- TransferData(anchorset = transfer.anchors, refdata = atlas.obj$cell_type, weight.reduction = query.obj[["pca"]],l2.norm = FALSE,dims = 1:25, k.weight = (nrow(transfer.anchors@anchors)-1))
}
query.obj <- AddMetaData(query.obj, metadata = celltype.predictions)
Idents(atlas.obj) <- atlas.obj$predicted.id
Idents(atlas.obj) <- atlas.obj$cell_type
p1 <- Plot.cluster2D(atlas.obj, reduction.method = "umap",pt_size = 0.4,txt = "atlas cell type")
p2
Idents(query.obj) <- query.obj$cell_type
p2 <- Plot.cluster2D(query.obj, reduction.method = "umap",pt_size = 0.4,txt = "query cell type")
Idents(query.obj) <- query.obj$celltype.predictions
p2 <- Plot.cluster2D(query.obj, reduction.method = "umap",pt_size = 0.4,txt = "query cell type")
celltype.predictions
query.obj <- AddMetaData(query.obj, metadata = celltype.predictions)
Idents(query.obj) <- query.obj$predicted.id
p2 <- Plot.cluster2D(query.obj, reduction.method = "umap",pt_size = 0.4,txt = "query cell type")
p2
# Save cell type labels
cell_info <- query.obj$predicted.id
cell_label <- cbind(colnames(query.obj),as.character(cell_info))
colnames(cell_label) <- c("cell_name","label")
cell_label <- cell_label[order(cell_label[,1]),]
write.table(cell_label,paste(query_data_id,"_cell_label.txt",sep = ""),quote = F,row.names = F,sep = "\t")
png(paste(query_data_id,"_transfer_umap.png",sep = ""),width=2000, height=2000,res=300)
plot_grid(p2)
dev.off()
meta <- read.csv('Zeisel_index_label.csv')
meta <- read.csv('Zeisel_index_label.csv')
query.obj <<- AddMetaData(query.obj, meta$Label, col.name = "cell_type")
query.obj <<- AddMetaData(query.obj, meta$Sex, col.name = "sex")
query.obj <<- AddMetaData(query.obj, meta$Sample, col.name = "sample")
Idents(query.obj) <- query.obj$cell_type
p1 <- Plot.cluster2D(query.obj, reduction.method = "umap",pt_size = 0.4,txt = "provided cell type")
p1
png(paste(query_data_id,"_provided_umap.png",sep = ""),width=2000, height=2000,res=300)
plot_grid(p1)
dev.off()
